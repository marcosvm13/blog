I"£A<p>This is the first instalmentÂ of a series of posts about the essence of functional programming. TheÂ onlyÂ purpose of this series isÂ to illustrate the defining features of thisÂ style of programming usingÂ different examplesÂ of increasing complexity. We will start with the ubiquitous â€œHello, world!â€ and will eventually arrive at â€¦ (throat clearing) monads. But we wonâ€™t argue that monads are the essence of functional programming, and, ultimately, do not intend these posts to be about monads. In fact, we will stumble uponÂ monads without actually looking for them, much in the same spirit of Dan Piponiâ€™sÂ â€<a href="http://blog.sigfpe.com/2006/08/you-could-have-invented-monads-and.html">You Could Have Invented Monads! (And Maybe You Already Have.)</a>â€.</p>

<p>There is a major difference between Danâ€™s post and theseÂ ones, however: weÂ wonâ€™t be usingÂ Haskell but Scala, a language which unlike Haskell is not purely functional, i.e. that allows us to write non-functional programs. But this feature wonâ€™t be a drawback at all. On the contrary, we think that itÂ will allow us to emphasise some aspects (e.g. the interpreters) that may go unnoticed usingÂ a language like Haskell.Â Letâ€™s start with our first example!</p>

<h2 id="hello-functional-world">Hello, functional world!</h2>
<p>This is a possibleÂ way of writing the â€œHello, world!â€ program in Scala:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Example1</span><span class="o">{</span>
  <span class="k">def</span> <span class="nf">hello</span><span class="o">()</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
    <span class="nf">println</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">)</span>
<span class="o">}</span>
</code></pre></div></div>

<p>which can be run in the Scala REPL as follows:</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Example1</span><span class="o">.</span><span class="py">hello</span><span class="o">()</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</code></pre></div></div>

<p>As you can see, when this function is run the message â€œHello, world!â€ is printed in the console. This is called a <em>side effect</em>, and it was indeed the purpose of the program. But this also means that ourÂ implementation is not purely functional. Why? Because functional programming is all about writing <em>pure</em> functions: functions which receive some input, compute some values and do <em>nothing else</em>. In a strongly-typed language such as Scala, we can witness the non-functional character of some functionÂ as follows: if the function does nothing else than returning values of the type declared in its signature, then itâ€™s a pure function; otherwise, itâ€™s anÂ <em>impure</em> function: its signature declares that it does one thing, but it also does something more behind the compilerâ€™s back.Â We may thus also say that impure functions work in the <em>black market</em>, beyond theÂ reachÂ of the compilerâ€™s type system (our best ally!).</p>

<p>But, if pure functions only allow us to return <em>values</em>, how can we then print something to the console? How can we then execute any kindÂ of effect (read something from the database, invoke a web service, write to a file, etc.)? How can we then do something useful at all? The answer is that you canâ€™t do those thingsÂ with pure functions alone. Functional programming rests upon a basic modularity principle which tells us to decompose our applicationsÂ into two kinds of modules: (1) functionalÂ modules, made up of pure functions thatÂ are responsible forÂ computing <em>what</em> has to be done, and (2) non-functionalÂ modules made up of impure functions or programsÂ in charge of actually <em>doing</em> it. Itâ€™s this latter kind of modules which will do the dirty job of actually interacting with the outside world and executing the desired effects; and itâ€™s the only responsibility of the functional modules to determine which effects have to be executed. When programming functionally, you should not forget this fact: impure functions will eventually be necessary. The only thing that functional programming mandates is to segregate impure functions, so that the <em>ivory tower</em> where pure functions live is as large as possible, and the <em>kitchen</em> where impure, side-effecting functions operateÂ is reduced to the bare minimum (which, nonetheless, in many applications mightÂ be quite large).</p>

<p>This limitation onÂ the things that functional programming can do is a self-imposed constraint thatÂ doesnâ€™t actually constrain itsÂ range of application domains. Indeed, we can apply the functional programming style to any kind of application domain you may think of.Â So, what about our impure â€œHello, world!â€ program? CanÂ we <em>purify</em> it? SureÂ we can. But then, how can we disentangle its pure and impure parts? Essentially, functional programming tells us toÂ proceed as follows (line numbersÂ refer to the code snippet bellow):</p>

<ul>
  <li>First, we define a <em>data typeÂ </em>that allows us to describeÂ theÂ kinds of effects we are dealing with<em>.Â </em>In our â€œHello, world!â€ example, we want to talk aboutÂ <em>printingÂ </em>strings somewhere, so we will define theÂ <code class="language-plaintext highlighter-rouge">PrintÂ </code>data type (cf. line 8).</li>
  <li>Second, we implement a function which <em>computes</em> the particular desired effectsÂ in terms of an instance of the previous data type. Our program then will be pretty simple (line 12): it simplyÂ returns the value <code class="language-plaintext highlighter-rouge">Print("Hello, world!")</code>. Note that this function isÂ pure!</li>
  <li>Third, we implement a function thatÂ receives an instance of the effectÂ data type, and executesÂ itÂ in anyÂ way we want. In our example, we will implement a function that receives a <code class="language-plaintext highlighter-rouge">PrintÂ </code>value and executes aÂ <code class="language-plaintext highlighter-rouge">println</code> instruction to write the desired message to the console (line 17). This function is thus impure!</li>
  <li>Last, we compose our program out of the previous two functions, obtaining, of course, an impure program (line 21).</li>
</ul>

<p>The resulting program is implemented in theÂ <code class="language-plaintext highlighter-rouge">Fun</code> module (pun intended):</p>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="k">object</span> <span class="nc">Example1</span><span class="o">{</span> 

  <span class="cm">/* Functional purification */</span>
  <span class="k">object</span> <span class="nc">Fun</span><span class="o">{</span>

    <span class="c1">// Language</span>
    <span class="k">type</span> <span class="kt">IOProgram</span> <span class="o">=</span> <span class="nc">Print</span>
    <span class="k">case</span> <span class="k">class</span> <span class="nc">Print</span><span class="o">(</span><span class="n">msg</span><span class="k">:</span> <span class="kt">String</span><span class="o">)</span>

    <span class="c1">// Program</span>
    <span class="k">def</span> <span class="nf">pureHello</span><span class="o">()</span><span class="k">:</span> <span class="kt">IOProgram</span> <span class="o">=</span>
      <span class="nc">Print</span><span class="o">(</span><span class="s">"Hello, world!"</span><span class="o">)</span>

    <span class="c1">// Interpreter</span>
    <span class="k">def</span> <span class="nf">run</span><span class="o">(</span><span class="n">program</span><span class="k">:</span> <span class="kt">IOProgram</span><span class="o">)</span><span class="k">:</span> <span class="kt">Unit</span> <span class="o">=</span>
      <span class="n">program</span> <span class="k">match</span> <span class="o">{</span>
        <span class="k">case</span> <span class="nc">Print</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">println</span><span class="o">(</span><span class="n">msg</span><span class="o">)</span>
      <span class="o">}</span>

    <span class="c1">// Composition</span>
    <span class="k">def</span> <span class="nf">hello</span><span class="o">()</span> <span class="k">=</span> <span class="nf">run</span><span class="o">(</span><span class="nf">pureHello</span><span class="o">())</span>
  <span class="o">}</span>
<span class="o">}</span>
</code></pre></div></div>

<p>The equivalent program to our initial impure solution <code class="language-plaintext highlighter-rouge">Example1.hello</code>Â is the (also impure) function <code class="language-plaintext highlighter-rouge">Example1.Fun.hello</code>. Both functions has the same functionality, i.e. they both do the same thing, and from the point of view of the functional requirements of our tiny application,Â they are both <em>correct.</em>Â However, they are far from being similar in terms of their reusability, composability, testability, and other non-functional requirements. We wonâ€™t explain in this post why the functional solution offers betterÂ non-functional guarantees, but ultimately the reason lies behind itsÂ better modularisation: whereas the <code class="language-plaintext highlighter-rouge">Example1.helloÂ </code>function is monolithic, its functional counterpart is made up of two parts: the <code class="language-plaintext highlighter-rouge">pureHelloÂ </code>function and the impure function <code class="language-plaintext highlighter-rouge">run</code>.</p>

<p>Now, anÂ important remark concerning the above code: note that we defined the aliasÂ <code class="language-plaintext highlighter-rouge">IOProgram</code> for our effect data type, and that we used the labelsÂ <em>Language</em>,Â <em>Program</em> andÂ <em>InterpreterÂ </em>forÂ the different parts of our functional solution. This is not accidental, and it pointsÂ at the <a href="https://www.youtube.com/watch?v=hmX2s3pe_qk">interpreter pattern</a>, arguably the essence of functional programming:</p>

<ul>
  <li>First, our effect data type can be regarded as theÂ <em>language</em> we use to describe the desired effects of our application. As part of this language, we can have different types of single effects, such as theÂ <code class="language-plaintext highlighter-rouge">Print</code> effect or instruction. Also,Â since languages are used to write programs, expressions in ourÂ effect languageÂ can be calledÂ <em>programs</em>, and we can use the word â€œprogramâ€ to name the type of the overall effect language. In our case, since we are dealing with IO effects, <code class="language-plaintext highlighter-rouge">IOProgram</code> is a good name. Last, note that the purpose of our language is very specific: we want to be able to write programs that just build uponÂ IO instructions, soÂ <code class="language-plaintext highlighter-rouge">IOProgram</code> is actually aÂ <em>domain-specific</em> language (DSL). Here there are some hand-crafted programs of our IO DSL:</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">Example1.Fun._</span>
<span class="k">import</span> <span class="nn">Example1.Fun._</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">program1</span><span class="k">:</span> <span class="kt">IOProgram</span> <span class="o">=</span> <span class="nc">Print</span><span class="o">(</span><span class="s">"hi!"</span><span class="o">)</span>
<span class="n">program1</span><span class="k">:</span> <span class="kt">Example1.Fun.IOProgram</span> <span class="o">=</span> <span class="nc">Print</span><span class="o">(</span><span class="n">hi</span><span class="o">!)</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">program2</span><span class="k">:</span> <span class="kt">IOProgram</span> <span class="o">=</span> <span class="nc">Print</span><span class="o">(</span><span class="s">"dummy program!"</span><span class="o">)</span>
<span class="n">program2</span><span class="k">:</span> <span class="kt">Example1.Fun.IOProgram</span> <span class="o">=</span> <span class="nc">Print</span><span class="o">(</span><span class="n">dummy</span> <span class="n">program</span><span class="o">!)</span>
</code></pre></div></div>
<ul>
  <li>So, pure functions return programs: this means thatÂ functional programming is intimatelyÂ related to metaprogramming! And when we say that functional programming isÂ <em>declarative</em>, we mean that functional programs justÂ <em>declare</em> orÂ <em>describe</em> what has to be done in terms of expressions or values. To convince yourself that ourÂ <code class="language-plaintext highlighter-rouge">pureHello</code> function is really declarative (i.e. pure), just execute it on the REPL. You will see that the only thing that happens during its execution is that a new value is computed by the runtime system (note that the outputÂ that youâ€™ll see in the REPL is not a result of theÂ <code class="language-plaintext highlighter-rouge">pureHello</code> execution, but of the REPL itself):</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Example1</span><span class="o">.</span><span class="py">Fun</span><span class="o">.</span><span class="py">pureHello</span><span class="o">()</span>
<span class="n">res1</span><span class="k">:</span> <span class="kt">Example1.Fun.IOProgram</span> <span class="o">=</span> <span class="nc">Print</span><span class="o">(</span><span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!)</span>
</code></pre></div></div>
<ul>
  <li>Once we execute a pure function and obtain a program, what is left is to actually <em>run</em> that program. But our program is an expression, pure syntax, so we have to choose a particular <em>interpretation</em> before we can actually run it.Â In our case, we chose to interpret our <code class="language-plaintext highlighter-rouge">IOProgram</code>s in term of console instructions, but we are free to interpret it otherwiseÂ (file IO, socket, etc.). When you run the program computed by our <code class="language-plaintext highlighter-rouge">pureHello</code>Â function, you will actually see the intended side effects:</li>
</ul>

<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">Example1</span><span class="o">.</span><span class="py">Fun</span><span class="o">.</span><span class="py">run</span><span class="o">(</span><span class="nv">Example1</span><span class="o">.</span><span class="py">Fun</span><span class="o">.</span><span class="py">pureHello</span><span class="o">())</span>
<span class="nc">Hello</span><span class="o">,</span> <span class="n">world</span><span class="o">!</span>
</code></pre></div></div>

<p>So, this is basically the structure of functional programming-based applications: domain-specific languages, pure functions that return programs in those DSLs, and interpreters that execute those programs. Note that these interpreters may be implemented in such a way thatÂ our programs are not directly executed but are instead translated to programs of some lower-levelÂ intermediate language (in a pure way). Eventually, however, we will reach the â€œbare metalâ€ and we will be able to observe some side effect in the real world.</p>

<p>The IO programs that we are able to expressÂ with our current definition of the type <code class="language-plaintext highlighter-rouge">IOProgram</code>Â are veryÂ simple. In fact, we can just create programs that write single messages. Accordingly, the range of impure functionsÂ that we can purify is pretty limited. In our next posts, weâ€™ll challenge our IO DSLÂ with more complex and realistic scenarios, and will see how it has to be extended in order to cope with them.</p>

<p><strong>Edit:</strong>Â All code from this post can be foundÂ <a href="https://github.com/hablapps/gist/blob/master/src/test/scala/hello-monads/partI.scala" target="_blank">here</a>.</p>

:ET