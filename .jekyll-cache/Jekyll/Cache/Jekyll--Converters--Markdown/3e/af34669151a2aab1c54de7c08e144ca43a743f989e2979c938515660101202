I"º‡<p>Q was implemented by <a href="https://queue.acm.org/detail.cfm?id=1531242">Arthur
Whitney</a> (Kx Systems), having its
first appearence in 2003. It relies on the shoulders of Kenneth E. Iverson and
his (Turing awarded) work on <em>A Programming Language</em> (APL) that started more
than six decades ago. Iverson emphasises the <a href="https://dl.acm.org/doi/pdf/10.1145/358896.358899">importance of
notation</a> to concentrate on
more advanced problems, and finds in programming languages the idoneous setting
to make math notation universal, executable and unambiguous. In accordance with
such spirit, most of the APL primitives are still available on q.</p>

<p>We cannot find a better overview for q as the one contained in the first pages
of <a href="https://www.q-tips.net">Q Tips</a>: <em>‚ÄúQ is an interpreted, dynamic,
event-driven, functional, array programming language.‚Äù</em>. That long definition
lets us infer why learning q becomes such a challenge. Letting the eternal war
between interpreted/compiled and dynamic/static aside (compiled and static
always win, right? :), this article focuses on the <em>functional</em> feature, where
we functional programmers can benefit from, since we have walked this road
before.</p>

<p>Although there is an emerging interest on <a href="https://www.efinancialcareers.co.uk/news/2017/05/kdbq-banking-alternatives">taking q and kdb beyond financial
services</a>,
we won‚Äôt be so original here and will use a trading indicator as an example. In
this sense, we‚Äôll try to keep it very easy.</p>

<blockquote>
  <p>Most of the q/kdb+ tutorials and code snippets revolve around trading
examples, so it is sometimes helpful to have an specialist nearby.</p>
</blockquote>

<p>Our indicator simply consists on calculating the max price of an instrument
(for instance: AAPL, AMZN, etc.) in the last year. We‚Äôll assume that the
instrument prices are organized as a kind of table containing all the working
days (Monday-Friday) within the last year. In turn, each of them contains a
price update for every second within the working hours (in particular, from
09:00 to 17:30). We split the problem in three steps, where each of them
corresponds to the following post sections:</p>
<ol>
  <li>Calculating the max of two numbers</li>
  <li>Calculating the max price within a day</li>
  <li>Calculating the max price within a whole year</li>
</ol>

<p>The first one is just a first contact with the language, where q operators and
types basics are introduced. The second one serves us as an excuse to show the
date api, lists, lambda expressions and <em>iterators</em> (which are essentially
higher order functions over collections). Finally, the last section presents
dictionaries and more iterators, where we briefly suggest connections with
functors and monads.</p>

<p>Throughout these posts, we will show q and scala snippets side by side. We want
to remark that our intention isn‚Äôt to provide a comparison of these languages,
though, but rather support our explanations by means of snippets from a more
conventional functional language such as Scala, for merely didactic purposes. We
encourage you to <a href="https://code.kx.com/q/learn/install/">install q</a> and type the
expressions below on your own.</p>

<h1 id="calculating-the-max-of-two-numbers">Calculating the max of two numbers</h1>

<p>The q language allows us to calculate the max of two numbers by means of the
operator <code class="language-plaintext highlighter-rouge">|</code>. We show how to use it in the following snippet, extracted from a
q REPL session, where <code class="language-plaintext highlighter-rouge">q)</code> acts as the default prompt:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="mi">3</span><span class="o">|</span><span class="mi">2</span>
<span class="mi">3</span>
</code></pre></div></div>
<p>Scala also has a REPL as part of its ecosystem, where the default prompt is
<code class="language-plaintext highlighter-rouge">scala&gt; </code>. We could translate the very same logic into Scala using the <code class="language-plaintext highlighter-rouge">max</code>
method from <code class="language-plaintext highlighter-rouge">Integer</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="mi">3</span> <span class="n">max</span> <span class="mi">2</span>
<span class="k">val</span> <span class="nv">res0</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>

<blockquote>
  <p>We could move <code class="language-plaintext highlighter-rouge">|</code> to its prefix notation, using a familiar syntax for
Haskellers, where we place the operator symbol in parentheses:</p>
  <div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="p">(</span><span class="o">|</span><span class="p">)[</span><span class="mi">3</span><span class="p">;</span><span class="mi">2</span><span class="p">]</span>
<span class="mi">3</span>
</code></pre></div>  </div>
  <p>As can be seen, the arguments are separated by semicolons and surrounded by
square brackets. As we‚Äôll see later, q supplies many flavours of syntactic
sugar while invoking functions beyond these ones, but we just wanted to remark
that the operator <code class="language-plaintext highlighter-rouge">|</code> could behave as any other function. This notion will
become relevant later on.</p>
</blockquote>

<p>In the previous snippets, we‚Äôve just produced an output and we‚Äôve let the REPL
to show it, but we could have assigned a name to the resulting value. The q
notation to introduce a variable <code class="language-plaintext highlighter-rouge">x</code> is as follows:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">x</span><span class="o">:</span><span class="mi">3</span><span class="o">|</span><span class="mi">2</span>
<span class="kd">q)</span><span class="n">x</span>
<span class="mi">3</span>
</code></pre></div></div>
<p>Which we translate into Scala by means of a <code class="language-plaintext highlighter-rouge">var</code> instead of a<code class="language-plaintext highlighter-rouge">val</code>, since q
variables can be reassigned:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span> <span class="n">max</span> <span class="mi">2</span>
<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span>
<span class="k">val</span> <span class="nv">res2</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">3</span>
</code></pre></div></div>
<p>Although q embraces immutability for a wide range of situations, it is clearly
not a pure functional language. It neither puts the same level of pressure on
avoiding mutable state as the one exhibited by Scala.</p>

<blockquote>
  <p>A remarkably interesting q feature is that variables can be introduced at any
point. For instance the expression <code class="language-plaintext highlighter-rouge">x:3|y:2</code> introduces <code class="language-plaintext highlighter-rouge">y</code> <em>on the fly</em> and
just returns its value to keep going. We‚Äôd need two different statements to do
that in Scala, as in <code class="language-plaintext highlighter-rouge">var y = 2; var x = 3 max y</code>.</p>
</blockquote>

<p>Another important aspect from the previous snippets are the variable types. We
can see that the Scala version indicates that the type of <code class="language-plaintext highlighter-rouge">x</code> is <code class="language-plaintext highlighter-rouge">Int</code>, although
we could have removed it and let the type inferencer work for us. In the case of
q, which is a dynamic language, we could use the <code class="language-plaintext highlighter-rouge">type</code> primitive to find it:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="nb">type</span><span class="w"> </span><span class="n">x</span>
<span class="o">-</span><span class="mi">7h</span>
</code></pre></div></div>
<p>Where you hoping to find something more familiar? Welcome to q! The number 7
indicates that the value of this type is a long; the negative symbol sugggests
an atomic value, i.e. not a list of longs; and the final <code class="language-plaintext highlighter-rouge">h</code> just manifests that
the value that <code class="language-plaintext highlighter-rouge">type</code> returns has <em>short</em> as type. You can find the complete
relation between numbers and types in <a href="https://code.kx.com/q/basics/datatypes/">this
section</a> from the official
documentation.</p>

<h1 id="calculating-the-max-price-within-a-day">Calculating the max price within a day</h1>

<p>Instead of assuming a predefined input list to play with, we find it convenient
to show how to generate a list of random prices. Once generated, we‚Äôll move on
to the actual calculation of the max value within it. Finally, we‚Äôll introduce a
variation of the problem, where we‚Äôll calculate the max value as long as it
doesn‚Äôt exceed a given limit.</p>

<h2 id="generating-random-prices-for-a-working-day">Generating random prices for a working day</h2>

<p>As mentioned before, we assume that the input includes a price update for every
single second between the range that goes from 09:00 to 17:30. How many seconds
are there in such interval?</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">n</span><span class="o">:</span><span class="mi">7h</span><span class="o">$</span><span class="ld">17:30:00</span><span class="o">-</span><span class="ld">09:00:00</span>
<span class="mi">30600</span>
</code></pre></div></div>
<blockquote>
  <p>Have you noticed the lack of space characters within q expressions? Q is
really committed to shortness and encourages the programmer to limit them.
This subtle difference has a considerable impact while reading q code,
although eventually, you get used to it.</p>
</blockquote>

<p>We clumsily adapt the previous expression into Scala using the <em>duration</em>
interface:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">import</span> <span class="nn">scala.concurrent.duration._</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">n</span> <span class="k">=</span> <span class="o">(</span><span class="mf">17.</span><span class="n">hours</span><span class="o">+</span><span class="mf">30.</span><span class="n">minutes</span> <span class="o">-</span> <span class="mf">9.</span><span class="n">hours</span><span class="o">).</span><span class="py">toSeconds</span>
<span class="k">val</span> <span class="nv">n</span><span class="k">:</span> <span class="kt">Long</span> <span class="o">=</span> <span class="mi">30600</span>
</code></pre></div></div>
<p>There are several aspects to discuss here, but we start emphasising that q
primitives for dates and times are just superb. Creating, operating and casting
different units of times is a clean, elegant and intuitive task. In the example
above, we just create the opening and closing seconds and then we subtract them.
We use the resulting output to calculate the number of seconds in the interval.
The most striking feature of the q snippet is perhaps the <code class="language-plaintext highlighter-rouge">7h$</code> at the
beginning, which somehow corresponds to the <code class="language-plaintext highlighter-rouge">toSeconds</code> invocation from the
Scala definition. In this sense, we use the <code class="language-plaintext highlighter-rouge">$</code> operator to cast an expression
to another type. As you already know, <code class="language-plaintext highlighter-rouge">7</code> is associated to the <em>long</em> type, so
we are casting the subtraction result to its numeric form.</p>

<blockquote>
  <p>At first sight, we could infer that <code class="language-plaintext highlighter-rouge">x$y-z</code> interprets the subtraction before
the casting due to <code class="language-plaintext highlighter-rouge">-</code> having a higher precedence. But this is not the case.
In fact, no q operator has higher precedende than another, since it will
always interpret expressions from right to left. For instance, <code class="language-plaintext highlighter-rouge">2*3+1</code> returns
<code class="language-plaintext highlighter-rouge">8</code>. If you combine this right-biased interpretation with the fact that it is
possible to introduce variable names at any point of an expression, you can
find yourself spending a non-negligible amount of time trying to understand
why the following expression does return <code class="language-plaintext highlighter-rouge">4</code>:</p>
  <div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">x</span><span class="o">:</span><span class="mi">0</span>
<span class="kd">q)</span><span class="n">x</span><span class="o">*</span><span class="mi">3</span><span class="o">+</span><span class="mi">2</span><span class="o">-</span><span class="n">x</span><span class="o">:</span><span class="mi">1</span>
<span class="mi">4</span>
</code></pre></div>  </div>
  <p>Notice that the second line rewrites <code class="language-plaintext highlighter-rouge">x</code> at the very beginning, remember, at
the rightmost expression. We show the Scala analogous to remark this aspect:</p>
  <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">var</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">0</span>
<span class="k">var</span> <span class="n">x</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">0</span>

<span class="n">scala</span><span class="o">&gt;</span> <span class="n">x</span> <span class="k">=</span> <span class="mi">1</span><span class="o">;</span> <span class="n">x</span> <span class="o">*</span> <span class="o">(</span><span class="mi">3</span> <span class="o">+</span> <span class="o">(</span><span class="mi">2</span> <span class="o">-</span> <span class="n">x</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">res3</span><span class="k">:</span> <span class="kt">Int</span> <span class="o">=</span> <span class="mi">4</span>
</code></pre></div>  </div>
  <p>Again, this way of interpreting code is yet another hurdle that makes q
difficult to read for newbies, but eventually, you get used to it (again
:smile:). Before moving on, we want to clarify that q programmers can change
associativity by using parenthesis, for instance: <code class="language-plaintext highlighter-rouge">(2*3)+1</code>, although it‚Äôs
more idiomatic to avoid them and reorder the code, if possible.</p>
</blockquote>

<p>Once we know the number of random prices that the intraday list will contain,
which we assigned to the variable <code class="language-plaintext highlighter-rouge">n</code>, it is time to generate them. To do so, we
simply use the <code class="language-plaintext highlighter-rouge">?</code> operator:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">prices</span><span class="o">:</span><span class="n">n</span><span class="o">?</span><span class="mf">1000f</span>
<span class="mf">231.8545</span><span class="w"> </span><span class="mf">102.0847</span><span class="w"> </span><span class="mf">974.3216</span><span class="w"> </span><span class="mf">673.6161</span><span class="w"> </span><span class="mf">404.1387</span><span class="w"> </span><span class="mf">626.0377</span><span class="w"> </span><span class="mf">211.9141</span><span class="w"> </span><span class="mf">604.1371</span><span class="w"> </span><span class="mf">52.77</span><span class="o">..</span>
</code></pre></div></div>
<p>Now, we show what we have considered its Scala counterpart by means of
<code class="language-plaintext highlighter-rouge">util.Random.nextFloat</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">prices</span> <span class="k">=</span> <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">(</span><span class="n">n</span><span class="o">)(</span><span class="n">nextFloat</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="mi">1000</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">prices</span><span class="k">:</span> <span class="kt">Seq</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">618.7332</span><span class="o">,</span> <span class="mf">216.10922</span><span class="o">,</span> <span class="mf">481.55737</span><span class="o">,</span> <span class="mf">257.13562</span><span class="o">,</span> <span class="mf">95.020</span><span class="o">..</span>
</code></pre></div></div>
<p>The previous snippets generate <code class="language-plaintext highlighter-rouge">n</code> float numbers in the range that goes from
zero to one thousand.</p>

<blockquote>
  <p>Note that the generation of random numbers by means of <code class="language-plaintext highlighter-rouge">?</code> is quite easy but
impure, since this operation isn‚Äôt referentially transparent. In fact, there
is a <a href="https://code.kx.com/q/basics/syscmds/#s-random-seed">global seed</a> which
is mutated when random values are demanded. We avoid introducing the <a href="https://livebook.manning.com/book/functional-programming-in-scala/chapter-6/">pure
approach embracing
seeds</a>
in Scala, to keep the comparison more direct.</p>
</blockquote>

<p>A nice feature from both q and Scala is that most of the time the output
reflects the very same code that we need to build such value. For instance, we
can generate a list of floats using the very same notation:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="mf">231.8545</span><span class="w"> </span><span class="mf">102.0847</span><span class="w"> </span><span class="mf">974.3216</span>
<span class="mf">231.8545</span><span class="w"> </span><span class="mf">102.0847</span><span class="w"> </span><span class="mf">974.3216</span>
</code></pre></div></div>
<p>whose associated type is <code class="language-plaintext highlighter-rouge">9h</code>, meaning a list of floats, and that we adapt to
Scala as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">231.8545f</span><span class="o">,</span> <span class="mf">102.0847f</span><span class="o">,</span> <span class="mf">974.3216f</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">res4</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="nc">List</span><span class="o">(</span><span class="mf">231.8545</span><span class="o">,</span> <span class="mf">102.0847</span><span class="o">,</span> <span class="mf">974.3216</span><span class="o">)</span>
</code></pre></div></div>
<p>Having generated a completely crazy list of intraday prices that nobody should
invest in, we will finally proceed to calculate its higher value.</p>

<blockquote>
  <p>We recommend the <em>Q Tips</em> book to find a more realistic generation of random
prices, which goes beyond the scope of this post.</p>
</blockquote>

<h2 id="finding-the-max-value">Finding the max value</h2>

<p>As functional programmers, we would find the greatest value by <em>folding</em> the
list. In q, the analogous for this function is the so-called <code class="language-plaintext highlighter-rouge">over</code> <em>iterator</em>
(<code class="language-plaintext highlighter-rouge">/</code>).</p>

<blockquote>
  <p>The notion of <em>iterator</em> in Scala refers to a different concept, namely
generators. Indeed, we should understand <a href="https://code.kx.com/q/ref/iterators/">q
iterators</a> as a catalogue of
higher-order functions over collections such as lists.</p>
</blockquote>

<p>This operator takes the reducing function and the list itself as input
arguments, so we could get the highest price by passing the <code class="language-plaintext highlighter-rouge">|</code> operator as
reducer:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="p">(</span><span class="o">|/</span><span class="p">)</span><span class="n">prices</span>
<span class="mf">999.9987</span>
</code></pre></div></div>
<p>We can get the analogous behaviour in Scala by using the <code class="language-plaintext highlighter-rouge">reduce</code> method and
<code class="language-plaintext highlighter-rouge">max</code> as reducer:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="n">max</span> <span class="k">_</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">res5</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">999.99884</span>
</code></pre></div></div>
<p>Obviously, they don‚Äôt lead to the very same output since each version produces
its own random numbers, but they are close enough!</p>

<p>As a pure and total functional programmer you might be missing the part of the
algebra that corresponds to the <code class="language-plaintext highlighter-rouge">Nil</code> (or empty list) case. In fact, <code class="language-plaintext highlighter-rouge">over</code>
would return <code class="language-plaintext highlighter-rouge">()</code> when we pass an empty list as second argument. This value
represents the empty list and I guess we could map it as a kind of Scala‚Äôs
<code class="language-plaintext highlighter-rouge">()</code>, which corresponds to the unique instance for the <em>Unit</em> type. So, to a
certain extent, we could consider that <code class="language-plaintext highlighter-rouge">(+/)</code> returns either <code class="language-plaintext highlighter-rouge">()</code> or the
greatest value, the dynamic poor man‚Äôs type for <code class="language-plaintext highlighter-rouge">Either[Unit, Float]</code>,
<a href="https://bartoszmilewski.com/2015/01/13/simple-algebraic-data-types/">isomorphic to the <code class="language-plaintext highlighter-rouge">Option</code>
type</a>. The
Scala version simply raises an exception when <code class="language-plaintext highlighter-rouge">reduce</code> is invoked from an empty
list. To make things safer, <code class="language-plaintext highlighter-rouge">over</code> can take an additional argument to take the
<code class="language-plaintext highlighter-rouge">Nil</code> case into account as well, as we show in the following snippet:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="mi">0</span><span class="o">|/</span><span class="n">prices</span>
<span class="mf">999.9987</span>
</code></pre></div></div>
<p>which would produce <code class="language-plaintext highlighter-rouge">0</code> when prices correspond to an empty list. From the Scala
viewpoint, we can use the pure <code class="language-plaintext highlighter-rouge">fold</code> method instead of <code class="language-plaintext highlighter-rouge">reduce</code> (which is
actually implemented as a <code class="language-plaintext highlighter-rouge">foldLeft</code>):</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="mf">0f</span><span class="o">)(</span><span class="n">max</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">res6</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">999.99884</span>
</code></pre></div></div>

<blockquote>
  <p>One of the fundamental pillars of APL is the <em>suggestivity</em> of notation,
where Iverson emphasises the importance of inferring new behaviours from
existing expressions. In this sense, we could guess that by passing the
operator <code class="language-plaintext highlighter-rouge">&amp;</code> that calculates the minumum of two values as an argument for
<code class="language-plaintext highlighter-rouge">over</code>, we should be able to obtain the lowest price:</p>
  <div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="p">(</span><span class="o">&amp;/</span><span class="p">)</span><span class="n">prices</span>
<span class="mf">0.0008079223</span>
</code></pre></div>  </div>
  <p>The same suggestivity applies to Scala, where we can pass the min function as
an argument to <code class="language-plaintext highlighter-rouge">reduce</code>:</p>
  <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">reduce</span><span class="o">(</span><span class="k">_</span> <span class="n">min</span> <span class="k">_</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">res7</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">0.02861023</span>
</code></pre></div>  </div>
</blockquote>

<p>Finally, we must say that calculating the maximum value from a given list is so
common, that q supplies <code class="language-plaintext highlighter-rouge">max</code> as an alias for <code class="language-plaintext highlighter-rouge">|/</code>, as in <code class="language-plaintext highlighter-rouge">max prices</code>. Scala
does also supply the analogous alternative, as in <code class="language-plaintext highlighter-rouge">prices.max</code>.</p>

<h2 id="finding-the-max-value-with-an-upper-bound">Finding the max value with an upper bound</h2>

<p>Calculating the maximum and minimum prices is ok, but we could be interested in
implementing more sophisticated indicators. For instance, calculating the higher
price that doesn‚Äôt exceed a given limit. At this point, one may wonder if <code class="language-plaintext highlighter-rouge">over</code>
is restricted to native predefined operators or if we could pass our own
operator as argument in order to implement that logic. Q, being a functional
language, provides support for lambda expressions, as we show next:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="mi">0</span><span class="p">{[</span><span class="n">x</span><span class="p">;</span><span class="n">y</span><span class="p">]</span><span class="o">$</span><span class="p">[</span><span class="n">y</span><span class="o">&lt;</span><span class="mf">500f</span><span class="p">;</span><span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">;</span><span class="n">x</span><span class="p">]}</span><span class="o">/</span><span class="n">prices</span>
<span class="mf">499.9798</span>
</code></pre></div></div>
<p>We rely on the Scala adaptation to explain what is going on:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="mf">0f</span><span class="o">)((</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="mf">500f</span><span class="o">)</span> <span class="n">x</span> <span class="n">max</span> <span class="n">y</span> <span class="k">else</span> <span class="n">x</span><span class="o">)</span>
<span class="k">val</span> <span class="nv">res8</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">499.98163</span>
</code></pre></div></div>
<p>As you can see, we replace <code class="language-plaintext highlighter-rouge">|</code> with the lambda expression that implements the
desired logic: getting the max of <code class="language-plaintext highlighter-rouge">x</code> and <code class="language-plaintext highlighter-rouge">y</code> as long as <code class="language-plaintext highlighter-rouge">y</code> is lower than
<code class="language-plaintext highlighter-rouge">500f</code>. The q lambda expression is surrounded by curly braces, where <code class="language-plaintext highlighter-rouge">[x;y]</code>
correspond to the input parameters, using a consistent notation with regard to
the argument passing style. The rest of the expression (<code class="language-plaintext highlighter-rouge">$[y&lt;500f;x|y;x]</code>) acts
as the body, where the <code class="language-plaintext highlighter-rouge">$</code> operator is therefore the analogous for an <code class="language-plaintext highlighter-rouge">if</code>
statement.</p>

<blockquote>
  <p>So far, we‚Äôve seen that the character <code class="language-plaintext highlighter-rouge">$</code> serves as the casting operator and
as the <em>if</em> statement. These kind of symbol overloading is very frequent and
turns out to be a major barrier to start reading q code from experienced
programmers. I guess that the same barrier applies for Scala newbies trying to
understand the many uses of the underscore symbol (<code class="language-plaintext highlighter-rouge">_</code>).</p>
</blockquote>

<p>It‚Äôs worth mentioning that when the parameter block is omitted, q will
understand names <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code> as the first, second and third parameters,
respectively. It‚Äôs quite similar to the Scala <em>placeholder</em> syntax (<code class="language-plaintext highlighter-rouge">_ + _</code>),
without the limitation of having to use each parameter exactly once. On its
part, q has the limitation of lacking additional names for functions with a
number of parameters greater than three. We apply this idea in the following
definition, where we parameterize the hardcoded limit as an additional argument
and assign the resulting function a name:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">lim</span><span class="o">:</span><span class="p">{</span><span class="o">$</span><span class="p">[</span><span class="n">y</span><span class="o">&lt;</span><span class="n">z</span><span class="p">;</span><span class="n">x</span><span class="o">|</span><span class="n">y</span><span class="p">;</span><span class="n">x</span><span class="p">]}</span>
</code></pre></div></div>
<p>The Scala counterpart would be:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">lim</span><span class="k">:</span> <span class="o">(</span><span class="kt">Float</span><span class="o">,</span> <span class="kt">Float</span><span class="o">,</span> <span class="nc">Float</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">Float</span> <span class="k">=</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nf">if</span> <span class="o">(</span><span class="n">y</span> <span class="o">&lt;</span> <span class="n">z</span><span class="o">)</span> <span class="n">x</span> <span class="n">max</span> <span class="n">y</span> <span class="k">else</span> <span class="n">x</span>
</code></pre></div></div>
<p>Unfortunately, we can exploit Scala placeholder syntax here.</p>

<p>Once we have defined the new name to get the maximum value which is in turn
lower than a given limit, we can modularise the previous logic:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="mi">0</span><span class="w"> </span><span class="n">lim</span><span class="p">[;;</span><span class="mf">500f</span><span class="p">]</span><span class="o">/</span><span class="n">prices</span><span class="w">	</span>
<span class="mf">499.9798</span>
</code></pre></div></div>
<p>We can adapt this code into Scala as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">fold</span><span class="o">(</span><span class="mf">0f</span><span class="o">)(</span><span class="nf">lim</span><span class="o">(</span><span class="k">_</span><span class="o">,</span> <span class="k">_</span><span class="o">,</span> <span class="mf">500f</span><span class="o">))</span>
<span class="k">val</span> <span class="nv">res10</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">499.88913</span>
</code></pre></div></div>
<p>As you have probably guessed by the Scala definition, what q achieves in
<code class="language-plaintext highlighter-rouge">lim[;;500f]</code> is to fix the third argument to <code class="language-plaintext highlighter-rouge">500f</code> and return a function that
still expects the first and second ones, as determined by the lack of arguments
for such positions. In q, this technique is known as <em>projection</em>.</p>

<blockquote>
  <p>Q deploys both the currified and non-currified versions of every function. In
this sense, <code class="language-plaintext highlighter-rouge">lim</code> can be invoked both as <code class="language-plaintext highlighter-rouge">lim[1;2;3]</code> and <code class="language-plaintext highlighter-rouge">lim[1][2][3]</code>. If
we combine this currying notion with projection, the flexibility of function
invocacion becomes astonishing. To illustrate it, we show further
alternatives for the very same invocation:</p>
  <div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">lim</span><span class="p">[</span><span class="mi">1</span><span class="p">][</span><span class="mi">2</span><span class="p">;</span><span class="mi">3</span><span class="p">]</span>
<span class="n">lim</span><span class="p">[;</span><span class="mi">2</span><span class="p">;][</span><span class="mi">1</span><span class="p">][</span><span class="mi">3</span><span class="p">]</span>
<span class="n">lim</span><span class="p">[;;</span><span class="mi">3</span><span class="p">][;</span><span class="mi">2</span><span class="p">][</span><span class="mi">1</span><span class="p">]</span>
<span class="n">lim</span><span class="p">[</span><span class="mi">1</span><span class="p">;;</span><span class="mi">3</span><span class="p">][</span><span class="mi">2</span><span class="p">]</span>
</code></pre></div>  </div>
</blockquote>

<p>Before moving on to the next section, we‚Äôd like to clarify that the <em>limit</em>
logic could benefit from a different implementation. In fact, we think that the
following code is more idiomatic in q:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="nb">max</span><span class="w"> </span><span class="n">prices</span><span class="w"> </span><span class="ow">where</span><span class="w"> </span><span class="n">prices</span><span class="o">&lt;</span><span class="mf">500f</span>
<span class="mf">499.9798</span>
</code></pre></div></div>
<p>The previous code could be adapted into Scala as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">filter</span><span class="o">(</span><span class="k">_</span> <span class="o">&lt;</span> <span class="mf">500f</span><span class="o">).</span><span class="py">max</span>
<span class="k">val</span> <span class="nv">res11</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">499.88913</span>
</code></pre></div></div>
<p>However, the q approach is radically different in the shadows, as the next post
will show.</p>

<h1 id="calculating-the-max-price-within-a-whole-year">Calculating the max price within a whole year</h1>

<p>Again, we find it interesting to generate the random prices from scratch. In
fact, instead of simply using a longer list of prices, we‚Äôll produce a list of
prices associated to every working day, to keep data tidier. Once generated,
we‚Äôll move on to the actual calculation of the max value within the brand new
structure.</p>

<h2 id="generating-a-whole-year-of-random-prices">Generating a whole year of random prices</h2>

<p>First of all, we‚Äôll use the techniques that we‚Äôve been learning on the previous
section to make the existing functions more reusable. For example, we adapt the
generation of the prices for a day as follows:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">rnd_prices</span><span class="o">:</span><span class="p">{(</span><span class="mi">7h</span><span class="o">$</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="p">)</span><span class="o">?</span><span class="n">z</span><span class="p">}</span>
</code></pre></div></div>
<p>As usual, we adapt the snippet into Scala:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">rnd_prices</span><span class="k">:</span> <span class="o">(</span><span class="kt">Duration</span><span class="o">,</span> <span class="kt">Duration</span><span class="o">,</span> <span class="nc">Float</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nc">List</span><span class="o">[</span><span class="kt">Float</span><span class="o">]</span> <span class="k">=</span> <span class="o">{</span>
     <span class="o">|</span>   <span class="nf">case</span> <span class="o">(</span><span class="n">x</span><span class="o">,</span> <span class="n">y</span><span class="o">,</span> <span class="n">z</span><span class="o">)</span> <span class="k">=&gt;</span> <span class="nv">List</span><span class="o">.</span><span class="py">fill</span><span class="o">((</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="o">).</span><span class="py">toSeconds</span><span class="o">)(</span><span class="n">nextFloat</span><span class="o">).</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="o">*</span> <span class="n">z</span><span class="o">)</span>
     <span class="o">|</span> <span class="o">}</span>
</code></pre></div></div>
<p>As you can see, we‚Äôve just parameterized the starting time, ending time and
higher price as <code class="language-plaintext highlighter-rouge">x</code>, <code class="language-plaintext highlighter-rouge">y</code> and <code class="language-plaintext highlighter-rouge">z</code>, respectively. This function will be reused to
generate different random prices for each working day.</p>

<p>Before moving on, we need to identify the working days within a range of dates.
We do so by means of the next function:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">working_days</span><span class="o">:</span><span class="p">{</span><span class="n">dates</span><span class="w"> </span><span class="ow">where</span><span class="p">((</span><span class="n">dates</span><span class="o">:</span><span class="n">x</span><span class="o">+</span><span class="nb">til</span><span class="p">(</span><span class="n">y</span><span class="o">-</span><span class="n">x</span><span class="p">))</span><span class="ow">mod</span><span class="w"> </span><span class="mi">7</span><span class="p">)</span><span class="o">&gt;</span><span class="mi">1</span><span class="p">}</span>
</code></pre></div></div>
<p>This time we avoid showing the Scala counterpart, since it would be far more
complex and doesn‚Äôt add value from a didactic perspective. Anyway, the previous
function just keeps working days, those whose modulo 7 is greater than 1. To
understand why, we need to take into account that q dates start counting on
2000.01.01, which happened to be Saturday. We supply the starting and ending
dates that allow us to collect the working days from 2020 (such a wonderful
year, huh?):</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">wds</span><span class="o">:</span><span class="n">working_days</span><span class="p">[</span><span class="ld">2020.01.01</span><span class="p">;</span><span class="ld">2021.01.01</span><span class="p">]</span>
</code></pre></div></div>
<p>We‚Äôll assume that such list was generated in Scala somehow:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">wds</span><span class="k">:</span> <span class="kt">List</span><span class="o">[</span><span class="kt">Date</span><span class="o">]</span> <span class="k">=</span> <span class="o">...</span>
</code></pre></div></div>

<p>Now, it‚Äôs time to associate the random prices for each working day. We do so by
means of the following expression, where two new features are introduced:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="n">prices</span><span class="o">:</span><span class="n">wds</span><span class="o">!</span><span class="p">{</span><span class="n">rnd_prices</span><span class="p">[</span><span class="ld">09:00:00</span><span class="p">;</span><span class="ld">17:30:00</span><span class="p">;</span><span class="mf">1000f</span><span class="p">]}</span><span class="ow">each</span><span class="w"> </span><span class="n">wds</span>
<span class="kd">q)</span><span class="n">prices</span>
<span class="ld">2020.01.01</span><span class="o">|</span><span class="w"> </span><span class="mf">447.9321</span><span class="w"> </span><span class="mf">687.9944</span><span class="w"> </span><span class="mf">491.4469</span><span class="w"> </span><span class="mf">426.7794</span><span class="w"> </span><span class="mf">650.8995</span><span class="w"> </span><span class="mf">147.1279</span><span class="w"> </span><span class="mf">440.327</span><span class="w">  </span><span class="mf">37.</span><span class="o">.</span>
<span class="ld">2020.01.02</span><span class="o">|</span><span class="w"> </span><span class="mf">601.4124</span><span class="w"> </span><span class="mf">818.0695</span><span class="w"> </span><span class="mf">549.0516</span><span class="w"> </span><span class="mf">985.867</span><span class="w">  </span><span class="mf">387.0052</span><span class="w"> </span><span class="mf">315.4341</span><span class="w"> </span><span class="mf">338.4381</span><span class="w"> </span><span class="mf">40.</span><span class="o">.</span>
<span class="ld">2020.01.03</span><span class="o">|</span><span class="w"> </span><span class="mf">811.1749</span><span class="w"> </span><span class="mf">237.0332</span><span class="w"> </span><span class="mf">220.7359</span><span class="w"> </span><span class="mf">435.7565</span><span class="w"> </span><span class="mf">190.276</span><span class="w">  </span><span class="mf">35.80185</span><span class="w"> </span><span class="mf">491.0418</span><span class="w"> </span><span class="mf">82.</span><span class="o">.</span>
<span class="ld">2020.01.06</span><span class="o">|</span><span class="w"> </span><span class="mf">780.8859</span><span class="w"> </span><span class="mf">5.676414</span><span class="w"> </span><span class="mf">286.5235</span><span class="w"> </span><span class="mf">149.7137</span><span class="w"> </span><span class="mf">568.0527</span><span class="w"> </span><span class="mf">916.0366</span><span class="w"> </span><span class="mf">66.16259</span><span class="w"> </span><span class="mf">46.</span><span class="o">.</span>
<span class="o">..</span>
</code></pre></div></div>
<p>It‚Äôs adapted into Scala as follows:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">prices</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Date</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Float</span><span class="o">]]</span> <span class="k">=</span>
     <span class="o">|</span>   <span class="nv">wds</span><span class="o">.</span><span class="py">zip</span><span class="o">(</span><span class="nv">wds</span><span class="o">.</span><span class="py">map</span><span class="o">(</span><span class="k">_</span> <span class="k">=&gt;</span> <span class="nf">rnd_prices</span><span class="o">(</span><span class="mf">9.</span><span class="n">hours</span><span class="o">,</span> <span class="mf">17.</span><span class="n">hours</span><span class="o">+</span><span class="mf">30.</span><span class="n">minutes</span><span class="o">,</span> <span class="mf">1000f</span><span class="o">))).</span><span class="py">toMap</span>

<span class="k">val</span> <span class="nv">prices</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Date</span>,<span class="kt">List</span><span class="o">[</span><span class="kt">Float</span><span class="o">]]</span> <span class="k">=</span> <span class="nc">Map</span><span class="o">(</span><span class="mf">2020.01</span><span class="o">.</span><span class="mi">01</span> <span class="o">-&gt;</span> <span class="nc">List</span><span class="o">(</span><span class="mf">977.59784</span><span class="o">,</span> <span class="mf">185.63521</span><span class="o">,</span>
<span class="mf">586.2779</span><span class="o">,</span> <span class="mf">221.09216</span><span class="o">,</span> <span class="mf">775.3352</span><span class="o">,</span> <span class="mf">645.992</span><span class="o">,</span> <span class="mf">206.07281</span><span class="o">,</span> <span class="mf">427.91003</span><span class="o">,</span> <span class="mf">166.2563</span><span class="o">,</span>
<span class="mf">639.81836</span><span class="o">,</span> <span class="mf">717.57886</span><span class="o">,</span> <span class="mf">842.7385</span><span class="o">,</span> <span class="mf">189.36241</span><span class="o">,</span> <span class="mf">755.4852</span><span class="o">,</span> <span class="mf">229.79778</span><span class="o">,</span> <span class="mf">548.248</span><span class="o">,</span>
<span class="mf">472.32468</span><span class="o">,</span> <span class="mf">383.4009</span><span class="o">,</span> <span class="mf">920.29846</span><span class="o">,</span> <span class="mf">211.65651</span><span class="o">,</span> <span class="mf">132.54398</span><span class="o">,</span> <span class="mf">514.35223</span><span class="o">,</span> <span class="mf">135.</span><span class="o">...</span>
</code></pre></div></div>
<p>On the one hand, we remark the iterator <code class="language-plaintext highlighter-rouge">each</code>. It corresponds to the <code class="language-plaintext highlighter-rouge">map</code>
invocation on the Scala snippet (that we functional programmers associate to
functors). In fact, they both allow us to apply a function over each element at
the collection. The mapper ignores the existing value, since the objective here
is to replace the date with the random prices.</p>

<blockquote>
  <p>The Scala version could avoid the <code class="language-plaintext highlighter-rouge">zip</code> invocation and reuse <code class="language-plaintext highlighter-rouge">map</code> for putting
dates and lists together:</p>
  <div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="k">val</span> <span class="nv">prices</span><span class="k">:</span> <span class="kt">Map</span><span class="o">[</span><span class="kt">Date</span>, <span class="kt">List</span><span class="o">[</span><span class="kt">Float</span><span class="o">]]</span> <span class="k">=</span>
     <span class="o">|</span>   <span class="nv">wds</span><span class="o">.</span><span class="py">map</span><span class="o">((</span><span class="k">_</span><span class="o">,</span> <span class="nf">rnd_prices</span><span class="o">(</span><span class="mf">9.</span><span class="n">hours</span><span class="o">,</span> <span class="mf">17.</span><span class="n">hours</span><span class="o">+</span><span class="mf">30.</span><span class="n">minutes</span><span class="o">,</span> <span class="mf">1000f</span><span class="o">))).</span><span class="py">toMap</span>
</code></pre></div>  </div>
  <p>However, we think that the original version has a better correspondence with
the q one.</p>
</blockquote>

<p>On the other hand, we must focus on the <code class="language-plaintext highlighter-rouge">!</code> operator as well, since it‚Äôs
introducing a major abstraction from q: <em>dictionaries</em>. Although the inner
implementation details may be completely different, I find it fair to compare
dictionaries with maps. The <code class="language-plaintext highlighter-rouge">!</code> operator is adapted as a combination of <code class="language-plaintext highlighter-rouge">zip</code>,
to place keys with values together, and <code class="language-plaintext highlighter-rouge">toMap</code>, to turn the list of pairs into
an actual map. By using it, we end up with a collection where each working day
has a list of prices associated.</p>

<h2 id="finding-the-max-value-1">Finding the max value</h2>

<p>Given the generated prices, we think that there are two main approaches to
calculate the higher price:</p>
<ul>
  <li>Calculate the maximum price for each day and then calculate the maximum one
among them</li>
  <li>Put all the prices together and just calculate the maximum one</li>
</ul>

<p>The first approach is carried out in the next code:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="nb">max</span><span class="w"> </span><span class="nb">max</span><span class="w"> </span><span class="ow">each</span><span class="w"> </span><span class="n">prices</span>
<span class="mf">999.9998</span>
</code></pre></div></div>
<p>that we can translate into Scala this way:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">mapValues</span><span class="o">(</span><span class="nv">_</span><span class="o">.</span><span class="py">max</span><span class="o">).</span><span class="py">max</span><span class="o">.</span><span class="py">_2</span>
<span class="k">val</span> <span class="nv">res12</span><span class="k">:</span> <span class="kt">Float</span> <span class="o">=</span> <span class="mf">999.9997</span>
</code></pre></div></div>
<p>As suggested by the Scala expression, when we use the <code class="language-plaintext highlighter-rouge">each</code> iterator over a
dictionary, we are actually applying the mapper over the values, keeping the
keys as is. Once we‚Äôve calculated the max value associated to each day, we can
invoke <code class="language-plaintext highlighter-rouge">max</code> directly over the resulting collection. In the Scala case, we need
to pick the value as a final step, since the involved key is also returned.</p>

<p>The second approach is implemented as follows:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="nb">max</span><span class="w"> </span><span class="nb">raze</span><span class="w"> </span><span class="n">prices</span>
<span class="mf">999.9998</span>
</code></pre></div></div>
<p>It is adapted into Scala using <code class="language-plaintext highlighter-rouge">flatten</code>:</p>
<div class="language-scala highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="n">scala</span><span class="o">&gt;</span> <span class="nv">prices</span><span class="o">.</span><span class="py">values</span><span class="o">.</span><span class="py">flatten</span><span class="o">.</span><span class="py">max</span>
</code></pre></div></div>
<p>Indeed, <code class="language-plaintext highlighter-rouge">raze</code> just flattens the dictionaries of lists, and roughly corresponds
to the <code class="language-plaintext highlighter-rouge">join</code> monadic operation. If we take into account that <code class="language-plaintext highlighter-rouge">,</code> is the list
concatenation operator, it should be straightforward to understand the
implementation of <code class="language-plaintext highlighter-rouge">raze</code>:</p>
<div class="language-q highlighter-rouge"><div class="highlight"><pre class="highlight"><code><span class="kd">q)</span><span class="nb">raze</span>
<span class="o">,/</span>
</code></pre></div></div>
<p>Indeed, it just uses the <code class="language-plaintext highlighter-rouge">over</code> iterator using <code class="language-plaintext highlighter-rouge">,</code> as reducer.</p>

<p>At this point we must say that the first approach is preferable, since it‚Äôs more
modular and therefore parallelizable. In fact, there‚Äôs a variant of <code class="language-plaintext highlighter-rouge">each</code> which
is referred to as <code class="language-plaintext highlighter-rouge">peach</code> that we could use to exploit such aspect. However, we
wanted to show the second approach since it‚Äôs almost mandatory for a functional
programming-related post to make <a href="https://mvanier.livejournal.com/3917.html"><em>yet another
monad</em></a> reference, isn‚Äôt it?</p>

<h1 id="takeaways">Takeaways</h1>

<ul>
  <li>Q enjoys the common traits of functional languages: lambdas, higher-order
functions, etc. with some nice features like projection.</li>
  <li>Q is not for the purest minds, given that side effects are the norm in certain
situations, such as the generation of random numbers or the reassignment of
variables.</li>
  <li>Although we acknowledge that q notation isn‚Äôt for everyone, we find it very
beautiful and extremely concise (even when we let the insane lack of space
characters and operator overloading aside).</li>
</ul>

<p>Before concluding, we must warn you that this post is far from reflecting the
real power of q. You should wait to our next post on array processing to see it!
It takes a while to experience the Zen, but you‚Äôll get a really powerful <em>tool
of thought</em> as a reward.</p>

<p><em>Post Picture: Trilog√≠a del desierto. Espejismo, Salvador Dal√≠ (1946)</em></p>
:ET